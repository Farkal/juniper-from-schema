use super::{ident, type_name, CodeGenPass, EmitError, TypeKind};
use crate::ast_pass::{error::ErrorKind, schema_visitor::SchemaVisitor};
use graphql_parser::schema::*;
use heck::{CamelCase, MixedCase, SnakeCase};
use proc_macro2::TokenStream;
use quote::quote;
use std::{
    collections::{HashMap, HashSet},
    hash::{Hash, Hasher},
};
use syn::Ident;

struct QueryTrailCodeGenPass<'pass, 'doc> {
    pass: &'pass mut CodeGenPass<'doc>,
    fields_map: HashMap<&'doc String, Vec<&'doc Field>>,
}

impl<'doc> CodeGenPass<'doc> {
    pub fn gen_query_trails(&mut self, doc: &'doc Document) {
        let original_tokens = std::mem::replace(&mut self.tokens, quote! {});

        let fields_map = build_fields_map(doc);

        let mut query_trail_pass = QueryTrailCodeGenPass {
            pass: self,
            fields_map,
        };
        query_trail_pass.gen_query_trail();
        query_trail_pass.visit_document(doc);

        let query_trail_tokens = &self.tokens;
        self.tokens = quote! {
            pub use juniper_from_schema::{Walked, NotWalked, QueryTrail, MakeQueryTrail};
            pub use self::query_trails::*;

            #original_tokens

            /// `QueryTrail` extension traits specific to the GraphQL schema
            ///
            /// Generated by juniper-from-schema
            pub mod query_trails {
                #![allow(unused_imports, dead_code, missing_docs)]

                use super::*;

                #query_trail_tokens
            }
        };
    }
}

impl<'pass, 'doc> QueryTrailCodeGenPass<'pass, 'doc> {
    fn gen_query_trail(&mut self) {
        self.pass.extend(quote! {
            use juniper_from_schema::{Walked, NotWalked, QueryTrail, MakeQueryTrail};

            /// Convert from one type of `QueryTrail` to another. Used for converting interface and
            /// union trails into concrete subtypes.
            ///
            /// This trait cannot live in juniper-from-schema itself because then we wouldn't be
            /// able to implement it for `QueryTrail` in the user's code. That would result in
            /// orphan instances.
            ///
            /// Generated by juniper-from-schema.
            pub trait DowncastQueryTrail<'a, T> {
                /// Perform the downcast.
                ///
                /// Generated by juniper-from-schema.
                fn downcast(self) -> QueryTrail<'a, T, Walked>;
            }
        })
    }

    fn gen_field_walk_methods(&mut self, obj: InternalQueryTrailNode<'_>) {
        let name = ident(&obj.name());
        let trait_name = ident(&format!("QueryTrail{}Extensions", obj.name()));
        let fields = obj.fields();

        let (method_signatures, method_implementations) = fields
            .iter()
            .map(|field| {
                let FieldWalkMethod {
                    method_signature,
                    method_implementation,
                } = self.gen_field_walk_method(field);
                (method_signature, method_implementation)
            })
            .unzip::<_, _, Vec<_>, Vec<_>>();

        self.pass.extend(quote! {
            pub trait #trait_name<'a> {
                #(#method_signatures)*
            }

            impl<'a, K> #trait_name<'a> for QueryTrail<'a, #name, K> {
                #(#method_implementations)*
            }
        });

        self.gen_conversion_methods(name, obj);
    }

    fn gen_conversion_methods(
        &mut self,
        original_type_name: Ident,
        obj: InternalQueryTrailNode<'_>,
    ) {
        let mut destination_types = vec![];

        match obj {
            InternalQueryTrailNode::Object(_) => {}
            InternalQueryTrailNode::Interface(i) => {
                if let Some(i) = &self.pass.ast_data.get_implementors_of_interface(&i.name) {
                    for interface_implementor_name in *i {
                        let ident = ident(interface_implementor_name);
                        destination_types.push(ident);
                    }
                }
            }
            InternalQueryTrailNode::Union(u, _) => {
                for type_ in &u.types {
                    let ident = ident(type_);
                    destination_types.push(ident);
                }
            }
        }

        for type_ in destination_types {
            self.pass.extend(quote! {
                impl<'a> DowncastQueryTrail<'a, #type_> for &QueryTrail<'a, #original_type_name, Walked> {
                    fn downcast(self) -> QueryTrail<'a, #type_, Walked> {
                        QueryTrail {
                            look_ahead: self.look_ahead,
                            node_type: std::marker::PhantomData,
                            walked: juniper_from_schema::Walked,
                        }
                    }
                }
            });
        }
    }

    fn error_msg_if_field_types_dont_overlap(&mut self, union: &'doc UnionType) {
        let fields_map = &self.fields_map;
        let mut prev: HashMap<&'doc str, (&'doc str, &'doc str)> = HashMap::new();

        for type_b in &union.types {
            if let Some(fields) = fields_map.get(type_b) {
                for field in fields {
                    let field_type_b = type_name(&field.field_type);

                    if let Some((type_a, field_type_a)) = prev.get(&field.name.as_ref()) {
                        if field_type_b != field_type_a {
                            self.pass.emit_non_fatal_error(
                                union.position,
                                ErrorKind::UnionFieldTypeMismatch {
                                    union_name: &union.name,
                                    field_name: &field.name,
                                    type_a: &type_a,
                                    type_b: &type_b,
                                    field_type_a: &field_type_a,
                                    field_type_b: &field_type_b,
                                },
                            );
                        }
                    }

                    prev.insert(&field.name, (type_b, field_type_b));
                }
            }
        }
    }

    fn gen_field_walk_method(&mut self, field: &Field) -> FieldWalkMethod {
        let field_type = type_name(&field.field_type);
        let (_, ty) = self
            .pass
            .graphql_scalar_type_to_rust_type(&field_type, field.position);
        let field_type = ident(field_type.clone().to_camel_case());

        match ty {
            TypeKind::Scalar => {
                let name = ident(&field.name.to_snake_case());
                let string_name = &field.name.to_mixed_case();

                let method_signature = quote! {
                    /// Check if a scalar leaf node is queried for
                    ///
                    /// Generated by `juniper-from-schema`.
                    fn #name(&self) -> bool;
                };

                let method_implementation = quote! {
                    fn #name(&self) -> bool {
                        use juniper::LookAheadMethods;

                        self.look_ahead
                            .and_then(|la| la.select_child(#string_name))
                            .is_some()
                    }
                };

                FieldWalkMethod {
                    method_signature,
                    method_implementation,
                }
            }
            TypeKind::Type => {
                let name = ident(&field.name.to_snake_case());
                let string_name = &field.name.to_mixed_case();

                let method_signature = quote! {
                    /// Walk the trail into a field.
                    ///
                    /// Generated by `juniper-from-schema`.
                    fn #name(&self) -> QueryTrail<'a, #field_type, juniper_from_schema::NotWalked>;
                };

                let method_implementation = quote! {
                    fn #name(&self) -> QueryTrail<'a, #field_type, juniper_from_schema::NotWalked> {
                        use juniper::LookAheadMethods;

                        let child = self.look_ahead.and_then(|la| la.select_child(#string_name));

                        QueryTrail {
                            look_ahead: child,
                            node_type: std::marker::PhantomData,
                            walked: juniper_from_schema::NotWalked,
                        }
                    }
                };

                FieldWalkMethod {
                    method_signature,
                    method_implementation,
                }
            }
        }
    }
}

impl<'pass, 'doc> SchemaVisitor<'doc> for QueryTrailCodeGenPass<'pass, 'doc> {
    fn visit_object_type(&mut self, obj: &'doc ObjectType) {
        self.gen_field_walk_methods(InternalQueryTrailNode::Object(obj))
    }

    fn visit_interface_type(&mut self, interface: &'doc InterfaceType) {
        self.gen_field_walk_methods(InternalQueryTrailNode::Interface(interface))
    }

    fn visit_union_type(&mut self, union: &'doc UnionType) {
        self.error_msg_if_field_types_dont_overlap(union);

        self.gen_field_walk_methods(InternalQueryTrailNode::Union(
            union,
            build_union_fields_set(union, &self.fields_map),
        ))
    }
}

struct FieldWalkMethod {
    method_signature: TokenStream,
    method_implementation: TokenStream,
}

#[derive(Clone)]
struct HashFieldByName<'a>(&'a Field);

impl<'a> PartialEq for HashFieldByName<'a> {
    fn eq(&self, other: &HashFieldByName) -> bool {
        self.0.name == other.0.name
    }
}

impl<'a> Eq for HashFieldByName<'a> {}

impl<'a> Hash for HashFieldByName<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.0.name.hash(state);
    }
}

enum InternalQueryTrailNode<'a> {
    Object(&'a ObjectType),
    Interface(&'a InterfaceType),
    Union(&'a UnionType, HashSet<HashFieldByName<'a>>),
}

impl<'a> InternalQueryTrailNode<'a> {
    fn name(&self) -> &String {
        match self {
            InternalQueryTrailNode::Object(inner) => &inner.name,
            InternalQueryTrailNode::Interface(inner) => &inner.name,
            InternalQueryTrailNode::Union(inner, _fields) => &inner.name,
        }
    }

    fn fields(&self) -> Vec<&'a Field> {
        match self {
            InternalQueryTrailNode::Object(inner) => inner.fields.iter().collect(),
            InternalQueryTrailNode::Interface(inner) => inner.fields.iter().collect(),
            InternalQueryTrailNode::Union(_inner, fields) => fields
                .iter()
                .map(|hashable_field| hashable_field.0)
                .collect(),
        }
    }
}

fn build_union_fields_set<'d>(
    union: &UnionType,
    fields_map: &HashMap<&'d String, Vec<&'d Field>>,
) -> HashSet<HashFieldByName<'d>> {
    let mut union_fields_set = HashSet::new();

    for type_ in &union.types {
        if let Some(fields) = fields_map.get(type_) {
            for field in fields {
                union_fields_set.insert(HashFieldByName(&field));
            }
        }
    }

    union_fields_set
}

fn build_fields_map(doc: &Document) -> HashMap<&String, Vec<&Field>> {
    let mut map = HashMap::new();

    for def in &doc.definitions {
        if let Definition::TypeDefinition(type_def) = def {
            if let TypeDefinition::Object(obj) = type_def {
                for field in &obj.fields {
                    let entry = map.entry(&obj.name).or_insert_with(|| vec![]);
                    entry.push(field);
                }
            }
        }
    }

    map
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::ast_pass::ast_data_pass::AstData;

    #[test]
    fn test_fails_to_generate_query_trail_for_unions_where_fields_dont_overlap() {
        let schema = r#"
            union Entity = User | Company

            type User {
              country: Country!
            }

            type Company {
              country: OtherCountry!
            }

            type Country {
              id: Int!
            }

            type OtherCountry {
              id: Int!
            }
        "#;

        let doc = graphql_parser::parse_schema(&schema).unwrap();
        let ast_data = AstData::new_from_schema_and_doc(&schema, &doc).unwrap();
        let mut out = CodeGenPass {
            tokens: quote! {},
            error_type: crate::parse_input::default_error_type(),
            context_type: crate::parse_input::default_context_type(),
            ast_data,
            errors: std::collections::BTreeSet::new(),
            raw_schema: schema,
        };

        out.gen_query_trails(&doc);

        assert_eq!(1, out.errors.len());
    }
}
