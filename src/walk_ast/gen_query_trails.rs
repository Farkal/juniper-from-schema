use super::{graphql_scalar_type_to_rust_type, ident, type_name, Output, TypeKind};
use graphql_parser::query::Name;
use graphql_parser::schema::NamedType;
use graphql_parser::schema::*;
use heck::{CamelCase, SnakeCase};
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::{HashMap, HashSet};
use std::hash::{Hash, Hasher};

pub fn gen_query_trails(doc: &Document, out: &mut Output) {
    gen_query_trail(out);

    let fields_map = build_fields_map(doc);

    for def in &doc.definitions {
        if let Definition::TypeDefinition(type_def) = def {
            match type_def {
                TypeDefinition::Object(obj) => {
                    gen_field_walk_methods(InternalQueryTrailNode::Object(obj), out)
                }
                TypeDefinition::Interface(interface) => {
                    gen_field_walk_methods(InternalQueryTrailNode::Interface(interface), out)
                }
                TypeDefinition::Union(union) => {
                    panic_if_field_types_dont_overlap(union, &fields_map);

                    gen_field_walk_methods(
                        InternalQueryTrailNode::Union(
                            union,
                            build_union_fields_set(union, &fields_map),
                        ),
                        out,
                    )
                }
                _ => {}
            }
        }
    }
}

fn gen_query_trail(out: &mut Output) {
    out.extend(quote! {
        /// A wrapper around a `juniper::LookAheadSelection` with methods for each possible child.
        ///
        /// Generated by `juniper-from-schema`.
        pub struct QueryTrail<'a, T, K> {
            look_ahead: Option<&'a juniper::LookAheadSelection<'a, juniper::DefaultScalarValue>>,
            node_type: std::marker::PhantomData<T>,
            walked: K,
        }

        impl<'a, T> QueryTrail<'a, T, NotWalked> {
            /// Check if the trail is present in the query being executed
            ///
            /// Generated by `juniper-from-schema`.
            pub fn walk(self) -> Option<QueryTrail<'a, T, Walked>> {
                match self.look_ahead {
                    Some(inner) => {
                        Some(QueryTrail {
                            look_ahead: Some(inner),
                            node_type: self.node_type,
                            walked: Walked,
                        })
                    },
                    None => None,
                }
            }
        }

        /// A type used to parameterize `QueryTrail` to know that `walk` has been called.
        pub struct Walked;

        /// A type used to parameterize `QueryTrail` to know that `walk` has *not* been called.
        pub struct NotWalked;

        trait MakeQueryTrail<'a> {
            fn make_query_trail<T>(&'a self) -> QueryTrail<'a, T, Walked>;
        }

        impl<'a> MakeQueryTrail<'a> for juniper::LookAheadSelection<'a, juniper::DefaultScalarValue> {
            fn make_query_trail<T>(&'a self) -> QueryTrail<'a, T, Walked> {
                QueryTrail {
                    look_ahead: Some(self),
                    node_type: std::marker::PhantomData,
                    walked: Walked,
                }
            }
        }
    })
}

#[derive(Clone)]
struct HashFieldByName(Field);

impl PartialEq for HashFieldByName {
    fn eq(&self, other: &HashFieldByName) -> bool {
        self.0.name == other.0.name
    }
}

impl Eq for HashFieldByName {}

impl Hash for HashFieldByName {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.0.name.hash(state);
    }
}

enum InternalQueryTrailNode<'a> {
    Object(&'a ObjectType),
    Interface(&'a InterfaceType),
    Union(&'a UnionType, HashSet<HashFieldByName>),
}

impl InternalQueryTrailNode<'_> {
    fn name(&self) -> &String {
        match self {
            InternalQueryTrailNode::Object(inner) => &inner.name,
            InternalQueryTrailNode::Interface(inner) => &inner.name,
            InternalQueryTrailNode::Union(inner, _fields) => &inner.name,
        }
    }

    fn fields(&self) -> Vec<Field> {
        match self {
            InternalQueryTrailNode::Object(inner) => inner.fields.clone(),
            InternalQueryTrailNode::Interface(inner) => inner.fields.clone(),
            InternalQueryTrailNode::Union(_inner, fields) => fields
                .iter()
                .map(|hashable_field| hashable_field.clone().0)
                .collect(),
        }
    }
}

fn gen_field_walk_methods(obj: InternalQueryTrailNode<'_>, out: &mut Output) {
    let name = ident(&obj.name());
    let fields = obj.fields();
    let methods = fields
        .iter()
        .map(|field| gen_field_walk_method(field, &out));

    out.extend(quote! {
        impl<'a, K> QueryTrail<'a, #name, K> {
            #(#methods)*
        }
    })
}

fn gen_field_walk_method(field: &Field, out: &Output) -> TokenStream {
    let field_type = type_name(&field.field_type);
    let (_, ty) = graphql_scalar_type_to_rust_type(&field_type, &out);
    let field_type = ident(field_type.clone().to_camel_case());

    match ty {
        TypeKind::Scalar => {
            let name = ident(&field.name.to_snake_case());
            let string_name = &field.name;

            quote! {
                /// Check if a scalar leaf node is queried for
                ///
                /// Generated by `juniper-from-schema`.
                pub fn #name(&self) -> bool {
                    use juniper::LookAheadMethods;

                    self.look_ahead
                        .and_then(|la| la.select_child(#string_name))
                        .is_some()
                }
            }
        }
        TypeKind::Type => {
            let name = ident(&field.name.to_snake_case());
            let string_name = &field.name;

            quote! {
                /// Walk the trail into a field.
                ///
                /// Generated by `juniper-from-schema`.
                pub fn #name(&self) -> QueryTrail<'a, #field_type, NotWalked> {
                    use juniper::LookAheadMethods;

                    let child = self.look_ahead.and_then(|la| la.select_child(#string_name));

                    QueryTrail {
                        look_ahead: child,
                        node_type: std::marker::PhantomData,
                        walked: NotWalked,
                    }
                }
            }
        }
    }
}

fn panic_if_field_types_dont_overlap(
    union: &UnionType,
    fields_map: &HashMap<NamedType, Vec<Field>>,
) {
    let mut prev: HashMap<Name, (NamedType, Name)> = HashMap::new();

    for type_ in &union.types {
        if let Some(fields) = fields_map.get(type_) {
            for field in fields {
                let field_name = field.name.clone();
                let field_type_name = type_name(&field.field_type);

                if let Some((type_with_other_field, other_type)) = prev.get(&field_name) {
                    if &field_type_name != other_type {
                        // NOTE: The error is not tested, change with care
                        let mut panic_msg = String::new();
                        panic_msg.push_str("\n");
                        panic_msg.push_str("\n");
                        panic_msg.push_str(&format!("Both `{}` and `{}` have a field named `{}` but those fields aren't of the same type\n", type_with_other_field, type_, field_name));
                        panic_msg.push_str(&format!(
                            "    `{}.{}` is of type `{}`\n",
                            type_with_other_field, field_name, other_type
                        ));
                        panic_msg.push_str(&format!(
                            "    `{}.{}` is of type `{}`",
                            type_, field_name, field_type_name
                        ));
                        panic_msg.push_str("\n");
                        panic_msg.push_str("\n");
                        panic!("{}", panic_msg);
                    }
                }

                prev.insert(field_name, (type_.to_string(), field_type_name));
            }
        }
    }
}

fn build_union_fields_set(
    union: &UnionType,
    fields_map: &HashMap<NamedType, Vec<Field>>,
) -> HashSet<HashFieldByName> {
    let mut union_fields_set = HashSet::new();

    for type_ in &union.types {
        if let Some(fields) = fields_map.get(type_) {
            for field in fields {
                union_fields_set.insert(HashFieldByName(field.clone()));
            }
        }
    }

    union_fields_set
}

fn build_fields_map(doc: &Document) -> HashMap<NamedType, Vec<Field>> {
    let mut map = HashMap::new();

    for def in &doc.definitions {
        if let Definition::TypeDefinition(type_def) = def {
            if let TypeDefinition::Object(obj) = type_def {
                for field in &obj.fields {
                    let entry = map.entry(obj.name.clone()).or_insert_with(|| vec![]);
                    entry.push(field.clone());
                }
            }
        }
    }

    map
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::walk_ast::{
        find_enum_variants::find_enum_variants,
        find_interface_implementors::find_interface_implementors,
        find_special_scalar_types::find_special_scalar_types,
    };

    #[test]
    #[should_panic]
    fn test_fails_to_generate_query_trail_for_unions_where_fields_dont_overlap() {
        let schema = r#"
            union Entity = User | Company

            type User {
              country: Country!
            }

            type Company {
              country: OtherCountry!
            }

            type Country {
              id: Int!
            }

            type OtherCountry {
              id: Int!
            }
        "#;

        let doc = graphql_parser::parse_schema(&schema).unwrap();

        let mut out = Output {
            tokens: quote! {},
            special_scalars: find_special_scalar_types(&doc),
            interface_implementors: find_interface_implementors(&doc),
            enum_variants: find_enum_variants(&doc),
        };

        gen_query_trails(&doc, &mut out);
    }
}
