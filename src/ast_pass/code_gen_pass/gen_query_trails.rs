use super::{graphql_scalar_type_to_rust_type, ident, type_name, CodeGenPass, TypeKind};
use graphql_parser::query::Name;
use graphql_parser::schema::NamedType;
use graphql_parser::schema::*;
use heck::{CamelCase, SnakeCase};
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::{HashMap, HashSet};
use std::hash::{Hash, Hasher};

impl<'doc> CodeGenPass<'doc> {
    pub fn gen_query_trails(&mut self, doc: &'doc Document) {
        self.gen_query_trail();

        let fields_map = build_fields_map(doc);
        let mut union_errors = Vec::new();

        for def in &doc.definitions {
            if let Definition::TypeDefinition(type_def) = def {
                match type_def {
                    TypeDefinition::Object(obj) => {
                        self.gen_field_walk_methods(InternalQueryTrailNode::Object(obj))
                    }
                    TypeDefinition::Interface(interface) => {
                        self.gen_field_walk_methods(InternalQueryTrailNode::Interface(interface))
                    }
                    TypeDefinition::Union(union) => {
                        if let Some(error) =
                            panic_msg_if_field_types_dont_overlap(union, &fields_map)
                        {
                            union_errors.push(error);
                        }

                        self.gen_field_walk_methods(InternalQueryTrailNode::Union(
                            union,
                            build_union_fields_set(union, &fields_map),
                        ))
                    }
                    _ => {}
                }
            }
        }

        if !union_errors.is_empty() {
            panic!("{}", union_errors.join("\n"));
        }
    }

    fn gen_query_trail(&mut self) {
        self.extend(quote! {
            /// A wrapper around a `juniper::LookAheadSelection` with methods for each possible child.
            ///
            /// Generated by `juniper-from-schema`.
            pub struct QueryTrail<'a, T, K> {
                look_ahead: Option<&'a juniper::LookAheadSelection<'a, juniper::DefaultScalarValue>>,
                node_type: std::marker::PhantomData<T>,
                walked: K,
            }

            impl<'a, T> QueryTrail<'a, T, NotWalked> {
                /// Check if the trail is present in the query being executed
                ///
                /// Generated by `juniper-from-schema`.
                pub fn walk(self) -> Option<QueryTrail<'a, T, Walked>> {
                    match self.look_ahead {
                        Some(inner) => {
                            Some(QueryTrail {
                                look_ahead: Some(inner),
                                node_type: self.node_type,
                                walked: Walked,
                            })
                        },
                        None => None,
                    }
                }
            }

            /// A type used to parameterize `QueryTrail` to know that `walk` has been called.
            pub struct Walked;

            /// A type used to parameterize `QueryTrail` to know that `walk` has *not* been called.
            pub struct NotWalked;

            trait MakeQueryTrail<'a> {
                fn make_query_trail<T>(&'a self) -> QueryTrail<'a, T, Walked>;
            }

            impl<'a> MakeQueryTrail<'a> for juniper::LookAheadSelection<'a, juniper::DefaultScalarValue> {
                fn make_query_trail<T>(&'a self) -> QueryTrail<'a, T, Walked> {
                    QueryTrail {
                        look_ahead: Some(self),
                        node_type: std::marker::PhantomData,
                        walked: Walked,
                    }
                }
            }
        })
    }

    fn gen_field_walk_methods(&mut self, obj: InternalQueryTrailNode<'_>) {
        let name = ident(&obj.name());
        let fields = obj.fields();
        let methods = fields
            .iter()
            .map(|field| gen_field_walk_method(field, &self));

        self.extend(quote! {
            impl<'a, K> QueryTrail<'a, #name, K> {
                #(#methods)*
            }
        })
    }
}

#[derive(Clone)]
struct HashFieldByName(Field);

impl PartialEq for HashFieldByName {
    fn eq(&self, other: &HashFieldByName) -> bool {
        self.0.name == other.0.name
    }
}

impl Eq for HashFieldByName {}

impl Hash for HashFieldByName {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.0.name.hash(state);
    }
}

enum InternalQueryTrailNode<'a> {
    Object(&'a ObjectType),
    Interface(&'a InterfaceType),
    Union(&'a UnionType, HashSet<HashFieldByName>),
}

impl InternalQueryTrailNode<'_> {
    fn name(&self) -> &String {
        match self {
            InternalQueryTrailNode::Object(inner) => &inner.name,
            InternalQueryTrailNode::Interface(inner) => &inner.name,
            InternalQueryTrailNode::Union(inner, _fields) => &inner.name,
        }
    }

    fn fields(&self) -> Vec<Field> {
        match self {
            InternalQueryTrailNode::Object(inner) => inner.fields.clone(),
            InternalQueryTrailNode::Interface(inner) => inner.fields.clone(),
            InternalQueryTrailNode::Union(_inner, fields) => fields
                .iter()
                .map(|hashable_field| hashable_field.clone().0)
                .collect(),
        }
    }
}

fn gen_field_walk_method(field: &Field, out: &CodeGenPass) -> TokenStream {
    let field_type = type_name(&field.field_type);
    let (_, ty) = graphql_scalar_type_to_rust_type(&field_type, &out);
    let field_type = ident(field_type.clone().to_camel_case());

    match ty {
        TypeKind::Scalar => {
            let name = ident(&field.name.to_snake_case());
            let string_name = &field.name;

            quote! {
                /// Check if a scalar leaf node is queried for
                ///
                /// Generated by `juniper-from-schema`.
                pub fn #name(&self) -> bool {
                    use juniper::LookAheadMethods;

                    self.look_ahead
                        .and_then(|la| la.select_child(#string_name))
                        .is_some()
                }
            }
        }
        TypeKind::Type => {
            let name = ident(&field.name.to_snake_case());
            let string_name = &field.name;

            quote! {
                /// Walk the trail into a field.
                ///
                /// Generated by `juniper-from-schema`.
                pub fn #name(&self) -> QueryTrail<'a, #field_type, NotWalked> {
                    use juniper::LookAheadMethods;

                    let child = self.look_ahead.and_then(|la| la.select_child(#string_name));

                    QueryTrail {
                        look_ahead: child,
                        node_type: std::marker::PhantomData,
                        walked: NotWalked,
                    }
                }
            }
        }
    }
}

fn panic_msg_if_field_types_dont_overlap(
    union: &UnionType,
    fields_map: &HashMap<NamedType, Vec<Field>>,
) -> Option<String> {
    let mut prev: HashMap<Name, (NamedType, Name)> = HashMap::new();
    let mut panic_msg = String::new();

    for type_ in &union.types {
        if let Some(fields) = fields_map.get(type_) {
            for field in fields {
                let field_name = field.name.clone();
                let field_type_name = type_name(&field.field_type);

                if let Some((type_with_other_field, other_type)) = prev.get(&field_name) {
                    if field_type_name != other_type {
                        // NOTE: The error is not tested, change with care
                        panic_msg.push_str("\n");
                        panic_msg.push_str("\n");
                        panic_msg.push_str(&format!(
                            "Error while generating `QueryTrail` code for union `{}`:",
                            union.name
                        ));
                        panic_msg.push_str("\n");
                        panic_msg.push_str(&format!("  Both `{}` and `{}` have a field named `{}` but those fields aren't of the same type\n", type_with_other_field, type_, field_name));
                        panic_msg.push_str(&format!(
                            "    `{}.{} :: {}`\n",
                            type_with_other_field, field_name, other_type
                        ));
                        panic_msg.push_str(&format!(
                            "    `{}.{} :: {}`",
                            type_, field_name, field_type_name
                        ));
                        panic_msg.push_str("\n");
                        panic_msg.push_str("\n");
                        panic_msg.push_str(&format!(
                            "  If `{union}` is `{union}::{variant}` then `QueryTrail::<_, {union}, _>::{field}()` would return `{type_}`\n",
                            union = union.name,
                            variant = type_with_other_field,
                            field = field_name,
                            type_ = other_type,
                        ));
                        panic_msg.push_str(&format!(
                            "  But if `{union}` is `{union}::{variant}` then `QueryTrail::<_, {union}, _>::{field}()` would return `{type_}`",
                            union = union.name,
                            variant = type_,
                            field = field_name,
                            type_ = field_type_name,
                        ));
                        panic_msg.push_str("\n");
                        panic_msg.push_str("\n");
                        panic_msg.push_str(&format!(
                            "  We can't have one method that returns different types :(",
                        ));
                        panic_msg.push_str("\n");
                    }
                }

                prev.insert(field_name, (type_.to_string(), field_type_name.to_string()));
            }
        }
    }

    if panic_msg.is_empty() {
        None
    } else {
        Some(panic_msg)
    }
}

fn build_union_fields_set(
    union: &UnionType,
    fields_map: &HashMap<NamedType, Vec<Field>>,
) -> HashSet<HashFieldByName> {
    let mut union_fields_set = HashSet::new();

    for type_ in &union.types {
        if let Some(fields) = fields_map.get(type_) {
            for field in fields {
                union_fields_set.insert(HashFieldByName(field.clone()));
            }
        }
    }

    union_fields_set
}

fn build_fields_map(doc: &Document) -> HashMap<NamedType, Vec<Field>> {
    let mut map = HashMap::new();

    for def in &doc.definitions {
        if let Definition::TypeDefinition(type_def) = def {
            if let TypeDefinition::Object(obj) = type_def {
                for field in &obj.fields {
                    let entry = map.entry(obj.name.clone()).or_insert_with(|| vec![]);
                    entry.push(field.clone());
                }
            }
        }
    }

    map
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::ast_pass::AstData;

    #[test]
    #[should_panic]
    fn test_fails_to_generate_query_trail_for_unions_where_fields_dont_overlap() {
        let schema = r#"
            union Entity = User | Company

            type User {
              country: Country!
            }

            type Company {
              country: OtherCountry!
            }

            type Country {
              id: Int!
            }

            type OtherCountry {
              id: Int!
            }
        "#;

        let doc = graphql_parser::parse_schema(&schema).unwrap();
        let ast_data = AstData::new(&doc);
        let mut out = CodeGenPass {
            tokens: quote! {},
            error_type: crate::parse_input::default_error_type(),
            ast_data,
        };

        out.gen_query_trails(&doc);
    }
}
