mod directives;
mod gen_query_trails;

use self::directives::panic_if_has_directives;
use super::{graphql_scalar_type_to_rust_type, ident, quote_ident, type_name, AstData, TypeKind};
use crate::nullable_type::NullableType;
use graphql_parser::{
    query::{Name, Type},
    schema::*,
};
use heck::{CamelCase, SnakeCase};
use lazy_static::lazy_static;
use proc_macro2::{TokenStream, TokenTree};
use quote::quote;
use regex::Regex;
use std::iter::Extend;
use syn::Ident;

pub struct CodeGenPass<'doc> {
    tokens: TokenStream,
    error_type: syn::Type,
    ast_data: AstData<'doc>,
}

impl<'doc> CodeGenPass<'doc> {
    pub fn new(error_type: syn::Type, ast_data: AstData<'doc>) -> Self {
        CodeGenPass {
            tokens: quote! {},
            error_type,
            ast_data,
        }
    }

    pub fn is_date_time_scalar_defined(&self) -> bool {
        self.ast_data.special_scalars.date_time_defined()
    }

    pub fn is_date_scalar_defined(&self) -> bool {
        self.ast_data.special_scalars.date_defined()
    }

    pub fn is_scalar(&self, name: &str) -> bool {
        self.ast_data.special_scalars.is_scalar(name)
    }

    pub fn is_enum(&self, name: &str) -> bool {
        self.ast_data.enum_variants.contains(name)
    }

    pub fn get_implementors_of_interface(&self, name: &str) -> Option<&Vec<&str>> {
        self.ast_data.interface_implementors.get(name)
    }
}

impl Extend<TokenTree> for CodeGenPass<'_> {
    fn extend<T: IntoIterator<Item = TokenTree>>(&mut self, iter: T) {
        self.tokens.extend(iter);
    }
}

impl Extend<TokenStream> for CodeGenPass<'_> {
    fn extend<T: IntoIterator<Item = TokenStream>>(&mut self, iter: T) {
        self.tokens.extend(iter);
    }
}

impl<'doc> CodeGenPass<'doc> {
    pub fn gen_juniper_code(mut self, doc: &'doc Document) -> TokenStream {
        self.gen_query_trails(doc);
        self.gen_enum_from_name();
        self.gen_doc(doc);
        self.tokens
    }

    fn gen_enum_from_name(&mut self) {
        self.extend(quote! {
            /// Trait generated by juniper-from-schema
            ///
            /// Used for mapping GraphQL enums such as `METER` to a Rust enum such as `Unit::Meter`.
            ///
            /// You shouldn't have to interact with this type directly
            #[allow(dead_code)]
            trait EnumFromGraphQlName {
                #[allow(missing_docs)]
                fn from_name(name: &str) -> Self;
            }
        });
    }

    fn gen_doc(&mut self, doc: &Document) {
        for def in &doc.definitions {
            self.gen_def(&def);
        }
    }

    fn gen_def(&mut self, def: &Definition) {
        use graphql_parser::schema::Definition::*;

        match def {
            DirectiveDefinition(_) => not_supported!("Directives"),
            SchemaDefinition(schema_def) => self.gen_schema_def(schema_def),
            TypeDefinition(type_def) => self.gen_type_def(type_def),
            TypeExtension(_) => not_supported!("Extensions"),
        }
    }

    fn gen_schema_def(&mut self, schema_def: &SchemaDefinition) {
        if schema_def.subscription.is_some() {
            not_supported!("Subscriptions");
        }

        panic_if_has_directives(&schema_def);

        let query = match &schema_def.query {
            Some(query) => ident(query),
            None => panic!("Juniper requires that the schema type has a query"),
        };

        let mutation = match &schema_def.mutation {
            Some(mutation) => quote_ident(mutation),
            None => quote! { juniper::EmptyMutation<Context> },
        };

        self.extend(quote! {
            /// The GraphQL schema type generated by `juniper-from-schema`.
            pub type Schema = juniper::RootNode<'static, #query, #mutation>;
        })
    }

    fn gen_type_def(&mut self, type_def: &TypeDefinition) {
        use graphql_parser::schema::TypeDefinition::*;

        match type_def {
            Enum(enum_type) => self.gen_enum_type(enum_type),
            Object(obj_type) => self.gen_obj_type(obj_type),
            Scalar(scalar_type) => self.gen_scalar_type(scalar_type),
            InputObject(input_object) => self.gen_input_def(input_object),
            Interface(interface_type) => self.gen_interface(interface_type),
            Union(union_type) => self.gen_union(&union_type),
        }
    }

    fn gen_obj_type(&mut self, obj_type: &ObjectType) {
        panic_if_has_directives(&obj_type);

        let struct_name = ident(&obj_type.name);

        let trait_name = trait_map_for_struct_name(&struct_name);

        let field_tokens = obj_type
            .fields
            .iter()
            .map(|field| self.collect_data_for_field_gen(field))
            .collect::<Vec<_>>();

        let trait_methods = field_tokens.iter().map(|field| {
            let field_name = &field.field_method;
            let field_type = &field.field_type;

            let args = &field.trait_args;

            let error_type = &self.error_type;

            match field.type_kind {
                TypeKind::Scalar => {
                    quote! {
                        /// Field method generated by `juniper-from-schema`.
                        fn #field_name<'a>(
                            &self,
                            executor: &juniper::Executor<'a, Context>,
                            #(#args),*
                        ) -> std::result::Result<#field_type, #error_type>;
                    }
                }
                TypeKind::Type => {
                    let query_trail_type = ident(&field.inner_type);
                    let trail = quote! { &QueryTrail<'a, #query_trail_type, Walked> };
                    quote! {
                        /// Field method generated by `juniper-from-schema`.
                        fn #field_name<'a>(
                            &self,
                            executor: &juniper::Executor<'a, Context>,
                            trail: #trail, #(#args),*
                        ) -> std::result::Result<#field_type, #error_type>;
                    }
                }
            }
        });

        self.extend(quote! {
            /// Trait for GraphQL field methods generated by `juniper-from-schema`.
            pub trait #trait_name {
                #(#trait_methods)*
            }
        });

        let fields = field_tokens
            .iter()
            .map(|field| gen_field(field, &struct_name, &trait_name, &self.error_type));

        let description = obj_type
            .description
            .as_ref()
            .map(|d| quote! { description: #d })
            .unwrap_or_else(empty_token_stream);

        let interfaces = if obj_type.implements_interfaces.is_empty() {
            empty_token_stream()
        } else {
            let interface_names = obj_type.implements_interfaces.iter().map(|name| {
                let name = ident(name);
                quote! { &#name }
            });
            quote! { interfaces: [#(#interface_names),*] }
        };

        self.extend(quote! {
            juniper::graphql_object!(#struct_name: Context |&self| {
                #description
                #(#fields)*
                #interfaces
            });
        })
    }

    fn gen_enum_type(&mut self, enum_type: &EnumType) {
        panic_if_has_directives(&enum_type);

        let name = to_enum_name(&enum_type.name);

        let trait_match_arms = enum_type
            .values
            .iter()
            .map(|value| {
                let graphql_name = &value.name;
                let variant = to_enum_name(&value.name);
                quote! {
                    #graphql_name => #name::#variant,
                }
            })
            .collect::<Vec<_>>();

        let values = enum_type
            .values
            .iter()
            .map(|enum_value| gen_enum_value(enum_value));

        let description = doc_tokens(&enum_type.description);

        self.extend(quote! {
            #description
            #[derive(juniper::GraphQLEnum, Debug, Eq, PartialEq, Copy, Clone, Hash)]
            pub enum #name {
                #(#values)*
            }
        });

        self.extend(quote! {
            impl EnumFromGraphQlName for #name {
                fn from_name(name: &str) -> Self {
                    match name {
                        #(#trait_match_arms)*
                        _ => panic!("The variant {:?} for `{}` is unknown", name, stringify!(#name)),
                    }
                }
            }
        })
    }

    fn gen_scalar_type(&mut self, scalar_type: &ScalarType) {
        panic_if_has_directives(&scalar_type);

        match &*scalar_type.name {
            "Date" => {}
            "DateTime" => {}
            name => {
                let name = ident(name);
                let description = &scalar_type
                    .description
                    .as_ref()
                    .map(|desc| quote! { description: #desc })
                    .unwrap_or(quote! {});

                self.gen_scalar_type_with_data(&name, &description);
            }
        };
    }

    fn gen_scalar_type_with_data(&mut self, name: &Ident, description: &TokenStream) {
        self.extend(quote! {
            /// Custom scalar type generated by `juniper-from-schema`.
            #[derive(Debug)]
            pub struct #name(pub String);

            juniper::graphql_scalar!(#name {
                #description

                resolve(&self) -> juniper::Value {
                    juniper::Value::string(&self.0)
                }

                from_input_value(v: &InputValue) -> Option<#name> {
                    v.as_string_value().map(|s| #name::new(s.to_owned()))
                }

                from_str<'a>(value: ScalarToken<'a>) -> juniper::ParseScalarResult<'a> {
                    <String as juniper::ParseScalarValue>::from_str(value)
                }
            });

            impl #name {
                fn new<T: Into<String>>(t: T) -> Self {
                    #name(t.into())
                }
            }
        })
    }

    fn gen_input_def(&mut self, input_object: &InputObjectType) {
        panic_if_has_directives(&input_object);

        let name = ident(&input_object.name);

        let fields = input_object.fields.iter().map(|field| {
            let arg = self.argument_to_name_and_rust_type(&field, &input_object.name);
            let name = ident(arg.name);
            let rust_type = arg.macro_type;

            let description = doc_tokens(&field.description);

            quote! {
                #[allow(missing_docs)]
                #description
                #name: #rust_type
            }
        });

        let description = doc_tokens(&input_object.description);

        self.extend(quote! {
            #[derive(juniper::GraphQLInputObject, Debug)]
            #description
            pub struct #name {
                #(#fields),*
            }
        })
    }

    fn argument_to_name_and_rust_type<'a>(
        &self,
        arg: &'a InputValue,
        context_type: &str,
    ) -> FieldArgument<'a> {
        panic_if_has_directives(&arg);

        let default_value = arg
            .default_value
            .as_ref()
            .map(|value| quote_value(&value, &context_type, &arg.name));

        let arg_name = arg.name.to_snake_case();

        let (macro_type, _) =
            self.gen_field_type(&arg.value_type, &FieldTypeDestination::Argument, false);

        let (trait_type, _) = self.gen_field_type(
            &arg.value_type,
            &FieldTypeDestination::Argument,
            default_value.is_some(),
        );

        FieldArgument {
            name: arg_name,
            macro_type,
            trait_type,
            default_value,
            description: &arg.description,
        }
    }

    fn gen_field_type(
        &self,
        field_type: &Type,
        destination: &FieldTypeDestination,
        has_default_value: bool,
    ) -> (TokenStream, TypeKind) {
        let field_type = NullableType::from_schema_type(field_type);

        if has_default_value && !field_type.is_nullable() {
            panic!("Fields with default arguments values must be nullable");
        }

        let field_type = if has_default_value {
            field_type.remove_one_layer_of_nullability()
        } else {
            field_type
        };

        let (tokens, ty) = self.gen_nullable_field_type(field_type);

        match (destination, ty) {
            (FieldTypeDestination::Return(attrs), ref ty) => match attrs.ownership() {
                Ownership::Owned => (tokens, *ty),
                Ownership::Borrowed => (quote! { &#tokens }, *ty),
            },

            (FieldTypeDestination::Argument, ty @ TypeKind::Scalar) => (tokens, ty),
            (FieldTypeDestination::Argument, ty @ TypeKind::Type) => (tokens, ty),
        }
    }

    fn gen_nullable_field_type(&self, field_type: NullableType) -> (TokenStream, TypeKind) {
        use crate::nullable_type::NullableType::*;

        match field_type {
            NamedType(name) => graphql_scalar_type_to_rust_type(&name, self),
            ListType(item_type) => {
                let (item_type, ty) = self.gen_nullable_field_type(*item_type);
                (quote! { Vec<#item_type> }, ty)
            }
            NullableType(item_type) => {
                let (item_type, ty) = self.gen_nullable_field_type(*item_type);
                (quote! { Option<#item_type> }, ty)
            }
        }
    }

    fn gen_interface(&mut self, interface: &InterfaceType) {
        panic_if_has_directives(&interface);

        let interface_name = ident(&interface.name);

        let description = &interface
            .description
            .as_ref()
            .map(|d| d.to_string())
            .unwrap_or_else(String::new);

        let implementors = self.get_implementors_of_interface(&interface.name);

        let implementors = if let Some(implementors) = implementors {
            implementors
        } else {
            panic!("There are no implementors of {}", interface.name)
        };

        let implementors = implementors.iter().map(ident).collect::<Vec<_>>();

        // Enum
        let variants = implementors.iter().map(|name| {
            quote! { #name(#name) }
        });
        self.extend(quote! {
            pub enum #interface_name {
                #(#variants),*
            }
        });

        // From implementations
        for variant in &implementors {
            self.extend(quote! {
                impl std::convert::From<#variant> for #interface_name {
                    fn from(x: #variant) -> #interface_name {
                        #interface_name::#variant(x)
                    }
                }
            });
        }

        // Resolvers
        let instance_resolvers = implementors.iter().map(|name| {
            quote! {
                &#name => match *self { #interface_name::#name(ref h) => Some(h), _ => None }
            }
        });

        let field_tokens: Vec<FieldTokens> = interface
            .fields
            .iter()
            .map(|field| self.collect_data_for_field_gen(field))
            .collect::<Vec<_>>();

        let field_token_streams = field_tokens
            .iter()
            .map(|field| {
                let field_name = &field.name;
                let args = &field.macro_args;
                let field_type = &field.field_type;

                let description = doc_tokens(&field.description);

                let arms = implementors.iter().map(|variant| {
                    let trait_name = trait_map_for_struct_name(&variant);
                    let struct_name = variant;

                    let body = gen_field_body(&field, &quote! {inner}, &struct_name, &trait_name);

                    quote! {
                        #interface_name::#struct_name(ref inner) => {
                            #body
                        }
                    }
                });

                let all_args = to_field_args_list(&args);

                let error_type = &self.error_type;

                quote! {
                    #description
                    field #field_name(#all_args) -> std::result::Result<#field_type, #error_type> {
                        match *self {
                            #(#arms),*
                        }
                    }
                }
            })
            .collect::<Vec<_>>();

        self.extend(quote! {
            graphql_interface!(#interface_name: Context |&self| {
                description: #description

                #(#field_token_streams)*

                instance_resolvers: |_| {
                    #(#instance_resolvers),*
                }
            });
        });
    }

    fn collect_data_for_field_gen<'a>(&self, field: &'a Field) -> FieldTokens<'a> {
        panic_if_has_directives(&field);

        let name = ident(&field.name);

        let inner_type = type_name(&field.field_type).to_camel_case();

        let attributes = field
            .description
            .as_ref()
            .map(|d| parse_attributes(&d))
            .unwrap_or_else(Attributes::default);

        let (field_type, type_kind) = self.gen_field_type(
            &field.field_type,
            &FieldTypeDestination::Return(attributes),
            false,
        );

        let field_method = ident(format!("field_{}", name.to_string().to_snake_case()));

        let args_data = field
            .arguments
            .iter()
            .map(|input_value| self.argument_to_name_and_rust_type(&input_value, &field.name))
            .collect::<Vec<_>>();

        let macro_args = args_data
            .iter()
            .map(|arg| {
                let name = ident(&arg.name);
                let arg_type = &arg.macro_type;
                let description = doc_tokens(&arg.description);
                quote! {
                    #description
                    #name: #arg_type
                }
            })
            .collect::<Vec<_>>();

        let trait_args = args_data
            .iter()
            .map(|arg| {
                let name = ident(&arg.name);
                let arg_type = &arg.trait_type;
                quote! { #name: #arg_type }
            })
            .collect::<Vec<_>>();

        let params = args_data
            .iter()
            .map(|arg| {
                let name = ident(&arg.name);
                if let Some(default_value) = &arg.default_value {
                    quote! {
                        #name.unwrap_or_else(|| #default_value)
                    }
                } else {
                    quote! { #name }
                }
            })
            .collect::<Vec<_>>();

        FieldTokens {
            name,
            macro_args,
            trait_args,
            field_type,
            field_method,
            params,
            description: &field.description,
            type_kind,
            inner_type,
        }
    }

    fn gen_union(&mut self, union: &UnionType) {
        panic_if_has_directives(&union);

        let union_name = ident(&union.name);
        let implementors = union.types.iter().map(ident).collect::<Vec<_>>();

        // Enum
        let variants = implementors.iter().map(|name| {
            quote! { #name(#name) }
        });
        self.extend(quote! {
            pub enum #union_name {
                #(#variants),*
            }
        });

        // From implementations
        for variant in &implementors {
            self.extend(quote! {
                impl std::convert::From<#variant> for #union_name {
                    fn from(x: #variant) -> #union_name {
                        #union_name::#variant(x)
                    }
                }
            })
        }

        // Resolvers
        let instance_resolvers = implementors.iter().map(|name| {
            quote! {
                &#name => match *self { #union_name::#name(ref h) => Some(h), _ => None }
            }
        });

        let description = union
            .description
            .as_ref()
            .map(|d| d.to_string())
            .unwrap_or_else(String::new);

        self.extend(quote! {
            graphql_union!(#union_name: Context |&self| {
                description: #description

                instance_resolvers: |_| {
                    #(#instance_resolvers),*
                }
            });
        });
    }
}

fn to_enum_name(name: &str) -> Ident {
    ident(name.to_camel_case())
}

fn gen_enum_value(enum_value: &EnumValue) -> TokenStream {
    panic_if_has_directives(&enum_value);

    let graphql_name = &enum_value.name;
    let name = to_enum_name(&graphql_name);
    let description = doc_tokens(&enum_value.description);

    quote! {
        #[allow(missing_docs)]
        #[graphql(name=#graphql_name)]
        #description
        #name,
    }
}

fn trait_map_for_struct_name(struct_name: &Ident) -> Ident {
    ident(format!("{}Fields", struct_name))
}

fn gen_field(
    field: &FieldTokens,
    struct_name: &Ident,
    trait_name: &Ident,
    error_type: &syn::Type,
) -> TokenStream {
    let field_name = &field.name;
    let field_type = &field.field_type;
    let args = &field.macro_args;

    let body = gen_field_body(&field, &quote! { &self }, struct_name, trait_name);

    let description = field
        .description
        .as_ref()
        .map(|d| d.to_string())
        .unwrap_or_else(|| String::new());

    let all_args = to_field_args_list(args);

    quote! {
        #[doc = #description]
        field #field_name(#all_args) -> std::result::Result<#field_type, #error_type> {
            #body
        }
    }
}

fn gen_field_body(
    field: &FieldTokens,
    self_tokens: &TokenStream,
    struct_name: &Ident,
    trait_name: &Ident,
) -> TokenStream {
    let field_method = &field.field_method;
    let params = &field.params;

    match field.type_kind {
        TypeKind::Scalar => {
            quote! {
                <#struct_name as self::#trait_name>::#field_method(#self_tokens, &executor, #(#params),*)
            }
        }
        TypeKind::Type => {
            let query_trail_type = ident(&field.inner_type);
            quote! {
                let look_ahead = executor.look_ahead();
                let trail = look_ahead.make_query_trail::<#query_trail_type>();
                <#struct_name as self::#trait_name>::#field_method(#self_tokens, &executor, &trail, #(#params),*)
            }
        }
    }
}

fn to_field_args_list(args: &[TokenStream]) -> TokenStream {
    if args.is_empty() {
        quote! { &executor }
    } else {
        quote! { &executor, #(#args),* }
    }
}

fn empty_token_stream() -> TokenStream {
    quote! {}
}

#[derive(Debug, Clone)]
struct FieldTokens<'a> {
    name: Ident,
    macro_args: Vec<TokenStream>,
    trait_args: Vec<TokenStream>,
    field_type: TokenStream,
    field_method: Ident,
    params: Vec<TokenStream>,
    description: &'a Option<String>,
    type_kind: TypeKind,
    inner_type: Name,
}

struct FieldArgument<'a> {
    name: Name,
    macro_type: TokenStream,
    trait_type: TokenStream,
    default_value: Option<TokenStream>,
    description: &'a Option<String>,
}

fn quote_value(value: &Value, context_type: &str, arg_name: &str) -> TokenStream {
    match value {
        Value::Float(inner) => quote! { #inner },
        Value::Int(inner) => {
            let number = inner
                .as_i64()
                .expect("failed to convert default number argument to i64");
            let number =
                i32_from_i64(number).expect("failed to convert default number argument to i64");
            quote! { #number }
        }
        Value::String(inner) => quote! { #inner.to_string() },
        Value::Boolean(inner) => quote! { #inner },

        Value::Enum(name) => {
            quote! { EnumFromGraphQlName::from_name(#name) }
        },

        Value::List(list) => {
            let mut acc = quote! { let mut vec = Vec::new(); };
            for value in list {
                let value_quoted = quote_value(value, context_type, arg_name);
                acc.extend(quote! { vec.push(#value_quoted); });
            }
            acc.extend(quote! { vec });
            quote! { { #acc } }
        },

        // Object is hard because the contained BTreeMap can have values of different types.
        // How do we quote such a map and convert it into the actual input type?
        Value::Object(_map) => {
            let mut panic_msg = String::new();
            panic_msg.push_str("\n");
            panic_msg.push_str("\n");
            panic_msg.push_str(&format!("Error encountered on `{}.{}`:\n", context_type, arg_name));
            panic_msg.push_str("  Default arguments where the type is an object is currently not supported.");
            panic_msg.push_str("\n");
            panic!("{}", panic_msg);
        }

        Value::Variable(_name) => panic!("Default arguments cannot refer to variables."),
        Value::Null => panic!("Having a default argument value of `null` is not supported. Use a nullable type instead."),
    }
}

// This can also be with TryInto, but that requires 1.34
fn i32_from_i64(i: i64) -> Option<i32> {
    if i > std::i32::MAX as i64 {
        None
    } else {
        Some(i as i32)
    }
}

enum FieldTypeDestination {
    Argument,
    Return(Attributes),
}

#[derive(Debug, Eq, PartialEq)]
enum Attribute {
    Ownership(Ownership),
}

#[derive(Debug, Eq, PartialEq, Copy, Clone)]
enum Ownership {
    Borrowed,
    Owned,
}

#[derive(Debug, Eq, PartialEq)]
struct Attributes {
    list: Vec<Attribute>,
}

impl std::default::Default for Attributes {
    fn default() -> Self {
        Attributes { list: Vec::new() }
    }
}

impl Attributes {
    #[allow(clippy::never_loop)]
    fn ownership(&self) -> Ownership {
        for attr in &self.list {
            match attr {
                Attribute::Ownership(x) => return *x,
            }
        }

        Ownership::Borrowed
    }
}

fn parse_attributes(desc: &str) -> Attributes {
    let attrs = desc
        .lines()
        .filter_map(|line| parse_attributes_line(line))
        .collect();
    Attributes { list: attrs }
}

lazy_static! {
    static ref ATTRIBUTE_PATTERN: Regex =
        Regex::new(r"\s*#\[(?P<key>\w+)\((?P<value>\w+)\)\]").unwrap();
}

fn parse_attributes_line(line: &str) -> Option<Attribute> {
    let caps = ATTRIBUTE_PATTERN.captures(line)?;
    let key = caps.name("key")?.as_str();
    let value = caps.name("value")?.as_str();

    let attr = match key {
        "ownership" => {
            let value = match value {
                "borrowed" => Ownership::Borrowed,
                "owned" => Ownership::Owned,
                _ => panic!("Unsupported attribute value '{}' for key '{}'", value, key),
            };
            Attribute::Ownership(value)
        }
        _ => panic!("Unsupported attribute key '{}'", key),
    };

    Some(attr)
}

fn doc_tokens(doc: &Option<String>) -> TokenStream {
    if let Some(doc) = doc {
        quote! {
            #[doc = #doc]
        }
    } else {
        quote! {}
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn parse_descriptions_for_attributes() {
        let desc = r#"
        Comment

        #[ownership(borrowed)]
        "#;
        let attributes = parse_attributes(desc);
        assert_eq!(attributes.ownership(), Ownership::Borrowed);

        let desc = r#"
        Comment

        #[ownership(owned)]
        "#;
        let attributes = parse_attributes(desc);
        assert_eq!(attributes.ownership(), Ownership::Owned);

        let desc = r#"
        Comment
        "#;
        let attributes = parse_attributes(desc);
        assert_eq!(attributes.ownership(), Ownership::Borrowed);
    }
}
